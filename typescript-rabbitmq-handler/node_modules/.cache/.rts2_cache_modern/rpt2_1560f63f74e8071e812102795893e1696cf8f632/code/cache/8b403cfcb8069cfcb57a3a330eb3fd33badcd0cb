{"code":"import amqp from \"amqplib\";\n/**\n * Клас для обробки з'єднань та взаємодії з RabbitMQ.\n */\nclass rabbitMQHandler {\n    connection;\n    channel;\n    /**\n     * Приватний конструктор для ініціалізації з'єднання та каналу.\n     * Використовується в статичному методі `create`.\n     */\n    constructor(connection, channel) {\n        this.connection = connection;\n        this.channel = channel;\n    }\n    /**\n     * Створює новий екземпляр `rabbitMQHandler` за допомогою\n     * заданого рядка підключення.\n     * @param connectionUri Рядок підключення до RabbitMQ.\n     * @returns Новий екземпляр `rabbitMQHandler`.\n     */\n    static async create(connectionUri) {\n        const connection = await amqp.connect(connectionUri);\n        const channel = await connection.createChannel();\n        process.once(\"SIGINT\", async () => {\n            await channel.close();\n            await connection.close();\n        });\n        console.log(\"Connected to RabbitMQ\");\n        return new rabbitMQHandler(connection, channel);\n    }\n    /**\n     * Підключається до RabbitMQ за допомогою заданого рядка підключення.\n     * @param connectionUri Рядок підключення до RabbitMQ.\n     */\n    async connect(connectionUri) {\n        try {\n            this.connection = await amqp.connect(connectionUri);\n            this.channel = await this.connection.createChannel();\n            process.once(\"SIGINT\", async () => {\n                await this.channel.close();\n                await this.connection.close();\n            });\n            console.log(\"Connected to RabbitMQ\");\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    }\n    /**\n     * Розпочинає прослуховування черги на вході та передає повідомлення для обробки.\n     * @param queueName Назва черги, яку слід прослуховувати.\n     * @param callback Функція-обробник повідомлень.\n     */\n    async startListening(queueName, callback) {\n        if (!this.channel) {\n            console.warn(\"RabbitMQ channel is not initialized.\");\n            return;\n        }\n        try {\n            await this.channel.assertQueue(queueName, { durable: false });\n            await this.channel.consume(queueName, async (message) => {\n                if (message) {\n                    const messageJson = message.content.toString();\n                    console.log(messageJson);\n                    const msg = JSON.parse(messageJson);\n                    await callback(msg);\n                }\n            }, { noAck: true });\n            console.log(` [*] Listening for messages in queue ${queueName}`);\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    }\n    /**\n     * Надсилає повідомлення до черги.\n     * @param queueName Назва черги, до якої слід надіслати повідомлення.\n     * @param message Повідомлення для надсилання.\n     */\n    async sendMessageToQueue(queueName, message) {\n        if (!this.channel) {\n            console.warn(\"RabbitMQ channel is not initialized.\");\n            return;\n        }\n        try {\n            await this.channel.assertQueue(queueName, { durable: false });\n            const messageJson = JSON.stringify(message);\n            this.channel.sendToQueue(queueName, Buffer.from(messageJson));\n            console.log(` [x] Sent to queue ${queueName}: ${messageJson}`);\n        }\n        catch (err) {\n            console.warn(err);\n        }\n    }\n}\nexport default rabbitMQHandler;\n","references":["D:/ITStep/NODEJS/typescript-rabbitmq-handler/node_modules/@types/amqplib/index.d.ts"],"dts":{"name":"D:/ITStep/NODEJS/typescript-rabbitmq-handler/dist/index.d.ts","writeByteOrderMark":false,"text":"/**\n * Тип для функції, яка обробляє повідомлення з RabbitMQ.\n */\nexport type consumerCallback<T> = (msg: T) => Promise<void>;\n/**\n * Клас для обробки з'єднань та взаємодії з RabbitMQ.\n */\ndeclare class rabbitMQHandler {\n    private connection;\n    private channel;\n    /**\n     * Приватний конструктор для ініціалізації з'єднання та каналу.\n     * Використовується в статичному методі `create`.\n     */\n    private constructor();\n    /**\n     * Створює новий екземпляр `rabbitMQHandler` за допомогою\n     * заданого рядка підключення.\n     * @param connectionUri Рядок підключення до RabbitMQ.\n     * @returns Новий екземпляр `rabbitMQHandler`.\n     */\n    static create(connectionUri: string): Promise<rabbitMQHandler>;\n    /**\n     * Підключається до RabbitMQ за допомогою заданого рядка підключення.\n     * @param connectionUri Рядок підключення до RabbitMQ.\n     */\n    private connect;\n    /**\n     * Розпочинає прослуховування черги на вході та передає повідомлення для обробки.\n     * @param queueName Назва черги, яку слід прослуховувати.\n     * @param callback Функція-обробник повідомлень.\n     */\n    startListening<T>(queueName: string, callback: consumerCallback<T>): Promise<void>;\n    /**\n     * Надсилає повідомлення до черги.\n     * @param queueName Назва черги, до якої слід надіслати повідомлення.\n     * @param message Повідомлення для надсилання.\n     */\n    sendMessageToQueue(queueName: string, message: any): Promise<void>;\n}\nexport default rabbitMQHandler;\n"}}
